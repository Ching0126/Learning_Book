# 第一次作业题

## 1

### （1）构造邻域方案

TSP 的邻域构造采用**2-opt 交换**（核心高效），具体规则：

- 随机选择路径中两个不同的索引`i`和`j`（`i<j`）。
- 反转路径中`i`到`j`之间的城市顺序，形成新路径（如`[1,2,3,4]`→选择`i=1,j=3`→`[1,3,2,4]`）。
- 该构造保证邻域解与当前解差异小，计算效率高，且能覆盖大部分可能的更优路径。

### （2）代码和运行结果截图

```python
import numpy as np
import matplotlib.pyplot as plt
import random
from matplotlib.patches import FancyArrowPatch

# -------------------------- 1. 基础数据与工具函数 --------------------------
# 30个城市坐标（严格对应题目给出顺序）
cities = np.array([
    [41, 94], [37, 84], [54, 67], [25, 62], [7, 64], [2, 99], [68, 58], [71, 44], [54, 62], [83, 69],
    [64, 60], [18, 54], [22, 60], [83, 46], [91, 38], [25, 38], [24, 42], [58, 69], [71, 71], [74, 78],
    [87, 76], [18, 40], [13, 40], [82, 7], [62, 32], [58, 35], [45, 21], [41, 26], [44, 35], [4, 50]
])
n_cities = len(cities)  # 城市数量（30）

# 计算两城市欧氏距离（保留6位小数）
def cal_distance(city1, city2):
    distance = np.sqrt(np.sum((city1 - city2) ** 2))
    return round(distance, 6)

# 计算路径总长度（含最后一个城市返回起点）
def path_length(path):
    total_length = 0.0
    for i in range(n_cities):
        # 第i个城市到第i+1个城市（最后一个到第0个）
        city_a_idx = path[i]
        city_b_idx = path[(i + 1) % n_cities]
        total_length += cal_distance(cities[city_a_idx], cities[city_b_idx])
    return total_length

# 绘制TSP路径图
def plot_tsp_path(path, title, save_flag=False):
    plt.figure(figsize=(10, 8))
    # 绘制城市散点
    plt.scatter(cities[:, 0], cities[:, 1], c='red', s=50, label='Cities')
    # 绘制路径（含返回起点）
    for i in range(n_cities):
        start = cities[path[i]]
        end = cities[path[(i + 1) % n_cities]]
        plt.plot([start[0], end[0]], [start[1], end[1]], c='blue', linewidth=1.5)
    # 标记起点（与终点重合，用不同颜色）
    start_point = cities[path[0]]
    plt.scatter(start_point[0], start_point[1], c='orange', s=100, label='Start/End')
    # 图表配置
    plt.title(title, fontsize=14)
    plt.xlabel('X Coordinate', fontsize=12)
    plt.ylabel('Y Coordinate', fontsize=12)
    plt.legend()
    plt.grid(alpha=0.3)
    if save_flag:
        plt.savefig(f'{title}.png', dpi=300, bbox_inches='tight')
    plt.show()

# -------------------------- 2. 爬山法实现 --------------------------
def tsp_hill_climbing(max_iter=15000):
    """
    爬山法求解TSP：2-opt交换构造邻域，仅接受更优解
    :param max_iter: 最大迭代次数
    :return: 最优路径、最优路径长度
    """
    # 1. 生成初始解（随机打乱城市索引）
    current_path = list(range(n_cities))
    random.shuffle(current_path)
    current_length = path_length(current_path)
    
    # 2. 迭代寻优
    for iter_idx in range(max_iter):
        # 生成邻域解（2-opt交换：随机选两个索引i<j，反转i-j之间的路径）
        i, j = random.sample(range(n_cities), 2)
        if i > j:
            i, j = j, i  # 确保i < j
        # 2-opt交换操作
        new_path = current_path[:i] + current_path[i:j+1][::-1] + current_path[j+1:]
        new_length = path_length(new_path)
        
        # 3. 接受准则：仅接受更优解
        if new_length < current_length:
            current_path = new_path
            current_length = new_length
    
    return current_path, current_length

# -------------------------- 3. 模拟退火实现 --------------------------
def tsp_simulated_annealing(init_temp=1200, cool_rate=0.95, min_temp=1e-4, max_iter=20000):
    """
    模拟退火求解TSP：Metropolis准则接受次优解，避免局部最优
    :param init_temp: 初始温度
    :param cool_rate: 降温系数（0<cool_rate<1）
    :param min_temp: 最低温度（终止条件1）
    :param max_iter: 最大迭代次数（终止条件2）
    :return: 全局最优路径、全局最优路径长度
    """
    # 1. 生成初始解
    current_path = list(range(n_cities))
    random.shuffle(current_path)
    current_length = path_length(current_path)
    # 记录全局最优（避免当前解波动丢失最优）
    best_path = current_path.copy()
    best_length = current_length
    
    # 2. 退火过程
    temp = init_temp  # 当前温度
    iter_count = 0    # 迭代计数器
    while temp > min_temp and iter_count < max_iter:
        # 生成邻域解（同爬山法：2-opt交换）
        i, j = random.sample(range(n_cities), 2)
        if i > j:
            i, j = j, i
        new_path = current_path[:i] + current_path[i:j+1][::-1] + current_path[j+1:]
        new_length = path_length(new_path)
        
        # 3. Metropolis接受准则
        delta = new_length - current_length  # 长度差（正：次优解，负：更优解）
        if delta < 0:
            # 接受更优解
            current_path = new_path
            current_length = new_length
            # 更新全局最优
            if current_length < best_length:
                best_path = current_path.copy()
                best_length = current_length
        else:
            # 以概率exp(-delta/temp)接受次优解
            accept_prob = np.exp(-delta / temp)
            if random.random() < accept_prob:
                current_path = new_path
                current_length = new_length
        
        # 4. 降温+迭代计数
        temp *= cool_rate
        iter_count += 1
    
    return best_path, best_length

# -------------------------- 4. 模拟退火参数影响分析 --------------------------
def sa_param_analysis(param_type='init_temp', param_list=None):
    """
    分析模拟退火关键参数对性能的影响（固定其他参数）
    :param param_type: 参数类型（'init_temp'：初始温度；'cool_rate'：降温系数）
    :param param_list: 待测试的参数列表
    """
    if param_list is None:
        # 默认测试参数范围
        if param_type == 'init_temp':
            param_list = [300, 600, 900, 1200, 1500, 1800]
        elif param_type == 'cool_rate':
            param_list = [0.85, 0.90, 0.92, 0.95, 0.97, 0.99]
    
    # 多次运行取平均（减少随机性影响）
    n_runs = 5
    avg_best_lengths = []
    for param in param_list:
        lengths = []
        for _ in range(n_runs):
            if param_type == 'init_temp':
                _, length = tsp_simulated_annealing(init_temp=param)
            else:
                _, length = tsp_simulated_annealing(cool_rate=param)
            lengths.append(length)
        avg_best_lengths.append(np.mean(lengths))
    
    # 绘制参数影响图
    plt.figure(figsize=(10, 6))
    plt.plot(param_list, avg_best_lengths, marker='o', linewidth=2.5, markersize=8, c='darkred')
    plt.xlabel(f'{param_type} (Parameter Value)', fontsize=12)
    plt.ylabel(f'Average Best Path Length', fontsize=12)
    plt.title(f'SA Performance vs {param_type}', fontsize=14)
    plt.grid(alpha=0.3)
    plt.savefig(f'SA_{param_type}_analysis.png', dpi=300, bbox_inches='tight')
    plt.show()

# -------------------------- 5. 主程序（运行与结果输出） --------------------------
if __name__ == "__main__":
    # 5.1 运行爬山法
    hc_path, hc_length = tsp_hill_climbing()
    print("="*50)
    print("爬山法求解TSP结果：")
    print(f"最优路径长度：{hc_length:.6f}")
    print(f"最优路径（城市索引）：{hc_path}")
    plot_tsp_path(hc_path, title=f'Hill Climbing TSP (Length: {hc_length:.2f})', save_flag=True)
    
    # 5.2 运行模拟退火
    sa_path, sa_length = tsp_simulated_annealing()
    print("\n" + "="*50)
    print("模拟退火求解TSP结果：")
    print(f"最优路径长度：{sa_length:.6f}")
    print(f"最优路径（城市索引）：{sa_path}")
    plot_tsp_path(sa_path, title=f'Simulated Annealing TSP (Length: {sa_length:.2f})', save_flag=True)
    
    # 5.3 分析参数影响（初始温度+降温系数）
    print("\n" + "="*50)
    print("开始分析模拟退火参数影响...")
    sa_param_analysis(param_type='init_temp')  # 初始温度影响
    sa_param_analysis(param_type='cool_rate')  # 降温系数影响
```

#### 爬山法寻最优解：<img src="C:\Users\qiyi\AppData\Roaming\Typora\typora-user-images\image-20251118214453548.png" alt="image-20251118214453548" style="zoom: 67%;" />

#### 模拟退火算法寻最优解：

<img src="C:\Users\qiyi\AppData\Roaming\Typora\typora-user-images\image-20251118214537503.png" alt="image-20251118214537503" style="zoom: 67%;" />

#### 运行截图：

![image-20251118214711438](C:\Users\qiyi\AppData\Roaming\Typora\typora-user-images\image-20251118214711438.png)

### （3）不同参数对模拟退火算法性能的影响

#### 初始温度对算法性能的影响

<img src="C:\Users\qiyi\AppData\Roaming\Typora\typora-user-images\image-20251118214547933.png" alt="image-20251118214547933" style="zoom: 67%;" />

#### 降温系数对算法性能的影响

<img src="C:\Users\qiyi\AppData\Roaming\Typora\typora-user-images\image-20251118214603425.png" alt="image-20251118214603425" style="zoom: 67%;" />

## 2

### （1）表示一个解

用长度为 9 的列表`color`表示解，`color[i]`对应节点`i+1`的颜色（取值 0、1、2，代表三种不同颜色）。

- 示例：`color = [0,1,2,0,1,2,0,1,2]` 表示节点 1→0 色、节点 2→1 色、...、节点 9→2 色。

### （2）构造初始解

随机选择一个节点，将其颜色替换为另外两种颜色中的一种（保证邻域解与当前解差异最小）：

```python
def generate_neighbor(solution):
    new_sol = solution.copy()
    node = random.randint(0, len(solution)-1)  # 随机选节点（索引0对应节点1）
    current_color = new_sol[node]
    # 选择不同的颜色
    new_color = random.choice([c for c in [0,1,2] if c != current_color])
    new_sol[node] = new_color
    return new_sol
```

### （3）构造邻域

随机选择一个节点，将其颜色替换为另外两种颜色中的一种（保证邻域解与当前解差异最小）：

```python
def generate_neighbor(solution):
    new_sol = solution.copy()
    node = random.randint(0, len(solution)-1)  # 随机选节点（索引0对应节点1）
    current_color = new_sol[node]
    # 选择不同的颜色
    new_color = random.choice([c for c in [0,1,2] if c != current_color])
    new_sol[node] = new_color
    return new_sol
```

### （4）代码和运行结果截图

```python
import random
import matplotlib.pyplot as plt

# 设置中文字体（仅保留Windows系统预装字体，避免找不到字体报错）
plt.rcParams["font.family"] = ["SimHei", "Microsoft YaHei", "黑体", "微软雅黑"]  # Windows常见中文字体
plt.rcParams["axes.unicode_minus"] = False  # 解决负号显示问题

# -------------------------- 1. 问题定义（用户指定无向图） --------------------------
edges = [
    (1, 2), (1, 3), (1, 4), (2, 5), (2, 9),
    (3, 8), (4, 7), (4, 8), (5, 6), (5, 8), (7, 9)
]
n_nodes = 9  # 节点数量（1~9）
colors = [0, 1, 2]  # 3种颜色（0、1、2）

# 手动定义节点坐标（固定位置，方便绘图）
node_pos = {
    1: (0, 2),    2: (-2, 1),   3: (0, 1),    4: (2, 1),
    5: (-2, 0),   6: (-3, -1),  7: (3, 0),    8: (0, 0),
    9: (-1, -1)
}

# -------------------------- 2. 核心函数定义 --------------------------
def init_solution():
    return [random.choice(colors) for _ in range(n_nodes)]

def conflict_count(solution):
    conflict_num = 0
    for (u, v) in edges:
        if solution[u - 1] == solution[v - 1]:
            conflict_num += 1
    return conflict_num

def generate_neighbor(solution):
    new_solution = solution.copy()
    node_idx = random.randint(0, n_nodes - 1)
    current_color = new_solution[node_idx]
    available_colors = [c for c in colors if c != current_color]
    new_color = random.choice(available_colors)
    new_solution[node_idx] = new_color
    return new_solution

# -------------------------- 3. 爬山法实现 --------------------------
def graph_coloring_hill_climbing(max_iter=10000, early_stop=True):
    current_sol = init_solution()
    current_conflict = conflict_count(current_sol)
    best_sol = current_sol.copy()
    best_conflict = current_conflict
    
    for iter_idx in range(max_iter):
        new_sol = generate_neighbor(current_sol)
        new_conflict = conflict_count(new_sol)
        
        if new_conflict < current_conflict:
            current_sol = new_sol
            current_conflict = new_conflict
            if current_conflict < best_conflict:
                best_sol = current_sol.copy()
                best_conflict = current_conflict
        
        if early_stop and best_conflict == 0:
            print(f"迭代{iter_idx+1}次找到可行解，提前终止！")
            break
    
    return best_sol, best_conflict

# -------------------------- 4. 结果可视化与输出 --------------------------
def plot_color_graph(solution, title):
    """用matplotlib手动绘制图形（无networkx依赖）"""
    plt.figure(figsize=(10, 8))
    
    # 颜色映射
    color_map = {0: 'red', 1: 'blue', 2: 'green'}
    color_names = {0: '红色', 1: '蓝色', 2: '绿色'}
    
    # 1. 绘制边
    for (u, v) in edges:
        x1, y1 = node_pos[u]
        x2, y2 = node_pos[v]
        plt.plot([x1, x2], [y1, y2], 'gray', linewidth=2, alpha=0.7)
    
    # 2. 绘制节点
    for node in range(1, n_nodes + 1):
        x, y = node_pos[node]
        color_code = solution[node - 1]
        plt.scatter(x, y, s=800, c=color_map[color_code], 
                   edgecolors='black', linewidths=2, zorder=3)  # zorder确保节点在边上
        # 节点标签（数字）
        plt.text(x, y, str(node), fontsize=14, fontweight='bold', 
                color='white', ha='center', va='center', zorder=4)
    
    # 添加颜色图例
    legend_elements = [
        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor='red', markersize=10, label='红色（0）'),
        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor='blue', markersize=10, label='蓝色（1）'),
        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor='green', markersize=10, label='绿色（2）')
    ]
    plt.legend(handles=legend_elements, loc='upper right', fontsize=12)
    
    # 图表配置
    plt.title(title, fontsize=14)
    plt.axis('off')  # 隐藏坐标轴
    plt.tight_layout()
    plt.savefig(f'{title}.png', dpi=300, bbox_inches='tight')
    plt.show()

def print_result(solution, conflict_num):
    print("="*60)
    print("3-图着色问题爬山法结果：")
    print(f"最小冲突数：{conflict_num}")
    print("\n节点-颜色对应关系：")
    for node in range(1, n_nodes + 1):
        color_code = solution[node - 1]
        color_name = {0: '红色', 1: '蓝色', 2: '绿色'}[color_code]
        print(f"节点{node:2d} → 颜色{color_code}（{color_name}）")
    if conflict_num == 0:
        print("\n✅ 找到可行解！所有相邻节点颜色不同。")
    else:
        print(f"\n❌ 未找到可行解，当前最小冲突数：{conflict_num}（可增加迭代次数重试）")
    print("="*60)

# -------------------------- 5. 主程序（运行与结果输出） --------------------------
if __name__ == "__main__":
    best_color_sol, min_conflict = graph_coloring_hill_climbing(max_iter=20000)
    print_result(best_color_sol, min_conflict)
    plot_title = f'3-图着色结果（冲突数：{min_conflict}）'
    plot_color_graph(best_color_sol, plot_title)
```

![image-20251118221707683](C:\Users\qiyi\AppData\Roaming\Typora\typora-user-images\image-20251118221707683.png)

<img src="C:\Users\qiyi\AppData\Roaming\Typora\typora-user-images\image-20251118221715021.png" alt="image-20251118221715021" style="zoom:67%;" />